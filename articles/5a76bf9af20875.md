---
title: "ちょっと面倒だなぁ～ってテキスト編集をなんとかする使い捨て十徳ナイフの作り方"
emoji: "😎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["vim"]
published: false
---

# はじめに
<!-- 複数ファイルに及ぶ大幅な変更というより、単純だけど面倒な編集 -->
どうも亀茶です。
vimを使っている時に、このテキスト編集…大規模編集ってわけでもなく地味に面倒だけど、
vimでの上手い手法がパッと思いつかねぇなぁ…
って時ありませんか？

私は最近ありました。

そんな時ふと良い手法を思いついて、案外汎用性ありそうだったので紹介いたします。

# 手頃な編集
<!-- vimでテキスト編集する時の便利な用途を紹介する感じにしたい -->
ここでいきなり手法をベタ張りしても良いのですが、
既にあるナイフやフォークの使い方を復習しておくのも重要だと思うので、
紹介しておきます。

:::message
`:help hoge`と表記されているものは、vimのヘルプを参照する際に
実際にvimに入力するコマンドです。
本記事で紹介するものよりもより詳細に記述されているので、適宜そちらを参照する事をお勧めします。
:::

## ドットマクロ
`:help single-repeat`で知られる`.`によって、簡易的な繰り返しを行うものです。
編集界隈でのナイフとも言えるでしょう。
ここで繰り返されるのは、「直前の変更」って事でして、
それとない概要としては以下のようになると思います。

- ノーマルモード → インサートモード → ノーマルモードで行った変更
- ノーマルモードで、移動キー(`h,j,k,l`等)で移動できるまでの変更
- 多分他にも色々ある…

:::message
変更って何？と改めて考えてみると不思議ですよね
vim上でのアンドゥ・リドゥの単位とも関係もありそうです。

そうした中で、vimの操作を
インサートモードとかいう概念ではなく、全てがコマンドであるという視点
で捉えた記事が良かったので紹介しておきます。
「[Vimエディタってどうしてあんな操作なの？](https://qiita.com/kagilinn/items/6cc1dffa04e3c50fd3e6)」
:::

これを駆使して、細やかな置換操作を行う事が多いと思います。
1. `/`で検索をする
2. `ciw`等で置換を行う
    - `cgn`等の`gn`で置換をすると、次の検索結果に移動しつつ置換も行えて便利です`:help gn`
3. `n`で次に同じ置換をしたい箇所へ移動
4. `.`で同じ置換を繰り返し

TODO: VHSでの実演

## マクロ
`:help complex-repeat`で知られるマクロ機能です。
ドットマクロがナイフ・フォークのナイフなら、マクロはペティナイフくらいのイメージあります。

マクロ記録中にタイプした文字列を、人がタイプしたのと同じように実行する事ができます。
イメージとしては、ドットマクロよりも編集の幅が広い箇所を繰り返す感じです。
モードに関係無くマクロ記録中に入力した文字なら何でも実行してくれるので、
なにかと融通が効きやすいです。

マクロの使い方としては以下のような感じです。
1. `qa`でマクロの記録を開始
    - ここでの`a`はレジスタ名で、何でも良いです(要help)
2. 適当に編集を行う
    - 編集中に動作するプラグインも機能するはずなので便利
3. `q`でマクロの記録を終了
4. `@a`でマクロを実行
    - 一度マクロを実行すると`@@`で直前のマクロを実行できるので、`@`を連打できて便利

これもドットリピートと同じく、
検索等でカーソルを移動させて、編集操作の塊ことマクロを次々と実行していく事が多いのかなと思います。

## コマンド
アーミーナイフくらいの感じがしますね。
TODO:
ここでのコマンドが何を

### 多重繰り返し
`:help multi-repeat`で知られる手法ですね。
選択範囲の中で特定箇所に対して、コマンドを繰り返す事ができます。
この特定箇所ってのがイチオシポイントでして、コマンドによる行変更によって変化しないんですよね。
なので、編集の前後で行数が変化するような操作でも繰り返しを行う事ができちゃいます。
<!-- `:global/hoge/d`とかの`:help multi-repeat`を使う手法 -->
<!-- `:normal @a`とか既存手法とからめて使う -->

### 外部コマンドとの連携
<!-- `:!jq`とか外部コマンドと組合せる手法 -->
`:help complex-change`で知られる手法ですね。
個人的にはあんまし使ってない…
良い外部コマンドを

# 使い捨て十徳ナイフ
簡単に言ってしまえば、`:help using-scripts`で紹介されている手法の一例って感じです。
テキスト編集自体をvimscriptで記述してしまうといった脳筋戦法ですね。
そう…全ては筋肉へと帰着するのです…

## 作り方
ひとえにvimscriptを使うといっても色々な方法があると思われますが、
今回はちょっと面倒だけど、使い易いであろう方を紹介します。
1. `:new`で新規バッファを開く
    - `:setfiletype vim`でvimscriptのシンタックスハイライトを有効にしても良い
2. `function! Hoge() abort ...`といった感じで関数を記述
3. `:source`で読み込む
4. 対象のバッファへ移動して、`:call Hoge()`で実行

といった感じです。
ここでポイントなのは、`:source`等でvimscriptを読み込む際に、スクリプトをファイル化しなくても良いという点です。
そう、まさしく†使い捨て†ですね。

## 使用例
例えば
```plaintext
ABCDEFGHIJKLMNOPQRSTUVWXYZ
```
から
```plaintext
- [ ] A
- [ ] B
...
- [ ] Z
```
のように変更したいとします。(こんな変換する事ないだろw的なのは置いておきます)

1. `:new`で新規バッファを開く
    - `:setfiletype vim`でvimscriptのシンタックスハイライトを有効にしても良い
2. `function! Hoge() abort ...`といった感じで関数を記述
	```vim
	function! Hoge() abort
		" 関数呼び出し時のカーソル行を取得
		let lnum = line('.')
		for word in split(getline('.'), '\zs')
			" append()で行を追加
			call append(lnum, "- [ ] " . word)
			let lnum += 1
		endfor
	endfunction
	```
3. `:source` or `:'<,'>source`で読み込む
4. 対象のバッファへ移動して、`:call Hoge()`で実行


## 何が起ってるのか
- vimはスクリプト環境でもある
	- 起動時意外でも`:source`でスクリプトを読み込む事ができる
- 普段プラグインもほぼ全部同じ仕組みで動いている
- これを発展させてくと†プラグイン†になる


:::message
`@=`でexpression registerを使っても同様の事ができそう
式の評価結果を自動挿入してくれて便利(venry)
`@=getline('.')->split('\zs')->map({_, v -> "- [ ] " . v })`
`:help @=`の事も明記しておきたい
<!-- `@=getline('.')->split('\zs')->map({_, v -> "$\\mathcal" . v . "$"})` -->
<!-- ↑これなんかバックスラッシュ`\`が入ると上手く動かん -->
:::

## 便利な組み込み関数
### カーソル系
### バッファ系
### 文字列操作系

:::message
ヘルプを見るとより詳細な説明や他の関数とかも見られるので、
ヘルプを見よう！
:::

# あとがき
気付けば紹介した手法が全部`:help repeating`に記載されているというね…
dmacroってのもあるみたいだし、近々触ってみたいかも
https://zenn.dev/dog/articles/dmacrod_2024
たかが繰り返し、されど繰り返し、繰り返しひとつとっても奥が深いなぁ
